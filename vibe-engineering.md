# 第一章 AI-First 工程基础

> 现代软件工程正在经历一场范式转移。这不是工具的升级，而是工作方式的重构。AI-First 不是简单的"把AI集成到开发流程中"，而是从根本上重新思考：在AI能力无限扩展的边界条件下，什么才是工程的核心价值？

本章将从真实工程问题出发，抽象出一套可迁移的工作流框架，帮助你建立AI时代的工程思维底座。

## 1.1 真实工程问题

让我们从一个典型的场景开始。

某天下午，你需要为一个SaaS产品添加"用户自定义工作流"功能。需求描述大致如下：用户可以创建多个步骤的业务流程，每个步骤可以配置条件分支，支持并行执行，需要可视化编辑器。

传统工程师的第一反应是什么？打开IDE，新建文件，开始写代码。三天后，你有了一个能跑的原型，但架构混乱，边界条件未处理，可扩展性为零。再过一周，需求变更，你开始修修补补，技术债像滚雪球一样累积。

AI时代的到来，让这个经典场景变得更加复杂。

### 问题一：Vibe Coding 陷阱

当你把需求扔给Claude或GPT-4，它能快速生成代码。你复制粘贴，跑通了。爽快感上头，你继续用同样的方式迭代。十次交互后，代码库变成了一团意大利面——每个AI回复的上下文窗口都是孤立的，没有整体架构意识，每次都在局部修bug。

这就是**Vibe Coding**：凭借直觉和感觉，让AI生成代码，快速验证，快速迭代，直到"感觉对了"。表面效率惊人，实则在积累不可见的技术债。

Vibe Coding的危险在于：
- **上下文碎片化**：每次对话都是新的起点，AI看不到全局
- **隐性知识丢失**：决策过程留在prompt里，没有沉淀为文档
- **架构漂移**：每次修改都是局部优化，整体一致性逐渐崩塌

### 问题二：AI角色的身份危机

当你问AI"如何设计这个工作流引擎"，它会给出一个完整方案。当你问"这个bug怎么修"，它会给出补丁。但问题是：**你在用它做什么？**

- 它是你的Architect？帮你设计系统
- 它是你的Senior Engineer？帮你review代码
- 它是你的Intern？帮你写实现
- 还是你的Search Engine？帮你查文档

大多数人的回答是"都是"。但问题在于：**没有清晰的分工，就没有清晰的责任边界**。当你让AI同时扮演所有角色，它也无法在每个角色上都做到最优。

### 问题三：时间分配的幻觉

传统开发的节奏是：想清楚(20%) → 写代码(60%) → 调试测试(20%)。

AI让"写代码"变得极快，但很多人误以为整个开发周期都加速了。实际上：
- **想清楚**变得更重要了——AI写的代码质量取决于你的指令质量
- **写代码**确实变快了，但**调试AI生成的代码**可能比调试自己写的更慢
- **测试和验证**变得更加关键——你不仅要验证功能，还要验证AI是否正确理解了你的意图

新的时间分配应该是怎样的？这正是本章要解决的核心问题。

## 1.2 工作流抽象

让我们从第一性原理出发，重新思考AI时代的开发工作流。

### EPB三阶段框架

经过大量实践验证，一个有效的AI-First工作流应该遵循 **Explore-Plan-Build** 三阶段：

```
Explore (探索)  →  Plan (规划)  →  Build (构建)
    20%             30-50%          20%
```

注意：这个时间分配与传统开发有根本性不同。**规划阶段的占比大幅提升**，因为AI的能力上限取决于指令质量，而指令质量取决于思考深度。

#### Explore阶段：边界探索

**目标**：理解问题的全貌，识别关键约束，避免错误方向。

**核心活动**：
1. **问题解构**：把模糊需求拆解为可验证的子问题
2. **约束识别**：技术栈约束、性能要求、团队技能边界
3. **信息收集**：阅读文档、搜索类似方案、建立知识地图

**AI角色定位**：Research Assistant / Knowledge Worker

**提示词模式**：
```
我需要实现 [功能描述]。请帮我：
1. 分析这个问题的技术难点和关键决策点
2. 列出需要了解的相关技术/库/框架
3. 给出3个可行的技术方案路径，并比较优劣
```

**退出条件**：
- 你能清晰描述问题边界
- 你知道不知道什么（known unknowns）
- 你有2-3个备选技术路径

#### Plan阶段：架构决策

**目标**：做出可执行的技术决策，生成清晰的任务清单。

**核心活动**：
1. **架构设计**：模块划分、接口定义、数据流设计
2. **任务分解**：WBS（Work Breakdown Structure），确定执行顺序
3. **风险预判**：识别可能的坑，准备应对方案

**AI角色定位**：**Staff Engineer** —— 这是关键！

> **为什么是Staff Engineer？**
>
> Plan阶段需要的是全局视角和架构思维。你要让AI扮演一个有多年经验的Staff Engineer：
> - 质疑你的假设
> - 指出潜在风险
> - 提供多种方案并给出trade-off分析
> - 考虑可维护性、可测试性、可扩展性
>
> 如果你让AI扮演Intern，它会给你一个能跑但不优雅的方案。
> 如果你让AI扮演Architect，它会给你一个完美但不现实的方案。
> **Staff Engineer是平衡点：务实且有前瞻性。**

**提示词模式**：
```
基于我们的讨论，我计划采用 [方案A]。请作为Staff Engineer review这个方案：
1. 指出潜在的技术风险
2. 评估长期的维护成本
3. 给出具体的改进建议
4. 如果这是你的项目，你会做哪些不同的决策？
```

**退出条件**：
- 有清晰的架构图或模块划分
- 有明确的任务列表，每个任务都有验收标准
- 主要风险已被识别，有应对策略

#### Build阶段：增量实现

**目标**：高质量地实现计划，保持架构一致性。

**核心活动**：
1. **增量编码**：按照Plan的任务清单，逐步实现
2. **持续验证**：每个增量都要测试，确保符合预期
3. **代码整理**：保持代码质量，及时重构

**AI角色定位**：**Senior Intern** —— 能干，需要指导

> **为什么是Senior Intern？**
>
> Build阶段，你需要的是执行力：
> - Intern：听话，按指令做事，但需要你明确指定细节
> - Senior Intern：有经验，能处理常见问题，但仍需要你的指导
> - Senior Engineer：太贵，用它做重复性的编码工作不划算
>
> **关键点**：你要做的是管理这个Intern，而不是自己写代码。你的价值在于：
> - 给出清晰的指令
> - Review它的产出
> - 指出方向性问题
> - 确保与整体架构一致**

**提示词模式**：
```
请实现 [具体任务]，要求：
1. 遵循我们约定的架构：[架构要点]
2. 使用 [技术栈/约定]
3. 代码要 [质量要求：可测试/可读性/错误处理]
4. 完成后自我review，检查是否符合所有要求
```

**退出条件**：
- 所有任务完成，测试通过
- 代码符合质量标准
- 有清晰的commit历史，便于回滚

### EPB的迭代特性

真实项目很少是线性的。更常见的情况是：

```
Explore → Plan → Build (发现问题) → Plan (调整) → Build (继续)
```

关键原则：
- **Explore阶段要充分**，避免方向性错误
- **Plan阶段要舍得花时间**，这里的时间投入会在Build阶段十倍收回
- **Build阶段要快速反馈**，发现问题及时回到Plan阶段

## 1.3 操作级流程

抽象框架之后，让我们落实到具体的操作层面。

### 开发会话的启动仪式

每次开始一个新的开发会话（新的聊天窗口），执行以下"仪式"：

```
1. [项目背景]
   - 这是一个什么类型的项目？
   - 当前处于什么阶段？
   - 主要的技术栈是什么？

2. [本次会话目标]
   - 今天要完成什么？
   - 输出物是什么？

3. [上下文加载]
   - 需要让AI了解哪些前置信息？
   - 相关的代码、文档、决策记录在哪里？

4. [角色设定]
   - 本次会话AI的角色是什么？（Researcher / Staff Engineer / Intern）
```

**模板示例**：
```
# Project Context
项目类型：React SaaS应用
当前阶段：功能开发
技术栈：React, TypeScript, Tailwind, Supabase

# Session Goal
实现用户自定义工作流功能的核心引擎

# Prerequisites
- 已阅读workflow-engine.md中的需求说明
- 架构决定采用有向无环图(DAG)模型
- 代码位于 src/workflow/ 目录

# AI Role
请扮演Staff Engineer角色，帮我设计模块结构和接口定义
```

### 对话节奏控制

#### 信息Chunking

一次对话不要试图解决太多问题。遵循 **单一职责原则**：
- 一个对话窗口 = 一个主题
- 完成后，总结关键信息，开启新对话

#### 状态检查点

每隔5-10轮交互，执行状态检查：
```
# 停下来检查
1. 我们在解决什么问题？
2. 当前方案是什么？
3. 下一步行动是什么？
4. 是否有遗漏的风险？
```

让AI总结当前状态，确保双方认知同步。

#### 决策记录

每个重要的技术决策，都要记录：
```
# 决议：[决策标题]

背景：
- 问题的简要描述

选项：
A. [方案A] - 优缺点
B. [方案B] - 优缺点

决策：
选择 [方案A]

理由：
- 为什么选这个
- 放弃了什么
- 潜在风险是什么

日期：YYYY-MM-DD
```

### 上下文管理策略

#### 代码上下文的传递

不要一次粘贴大量代码。采用**分层摘要**：
```
L1: 项目结构树
L2: 关键模块接口
L3: 具体实现代码（按需）

当AI需要了解某个函数时，再提供L3细节
```

#### 知识的累积构建

使用"知识累积文件"（.kc.md）：
```
# workflow-engine.kc.md

## 核心概念
- DAG：有向无环图，表示工作流的结构
- Node：工作流中的单个步骤
- Edge：连接节点的依赖关系

## 已做决策
- [决策记录的链接或简述]

## 待解决问题
- [问题列表]

## 相关代码
- src/workflow/dag.ts - DAG核心实现
- src/workflow/executor.ts - 执行引擎
```

每次会话开始前，先读取相关的.kc.md文件。

## 1.4 常见失败模式

了解什么**不该做**，有时比知道**该做什么**更重要。以下是实践中总结的常见失败模式。

### 模式一：Prompt Drift

**症状**：
- 对话开始时目标清晰，20轮后已经偏到十万八千里
- AI开始建议与你初始目标无关的优化
- 你忘记了自己最初想解决的问题

**根本原因**：
- 缺少显式的目标锚定
- 没有定期检查对齐

**应对策略**：
```
# 每5轮对话后
请总结：
1. 我们的原始目标是什么
2. 当前我们处于什么状态
3. 下一步应该做什么
```

### 模式二：Context Collapse

**症状**：
- AI开始遗忘之前的约定
- 代码风格前后不一致
- 重复讨论已经解决的问题

**根本原因**：
- 上下文窗口溢出（虽然现在模型很长了，但仍可能发生）
- 信息密度不足，关键信息被淹没

**应对策略**：
- 使用.kc.md文件维护"记忆"
- 每次会话开始时，加载必要的前置信息
- 发现AI遗忘时，重新声明约定

### 模式三：Yes-Man Trap

**症状**：
- AI总是同意你的建议，很少质疑
- 你意识不到潜在问题，直到后期才发现
- Code review变成了形式化流程

**根本原因**：
- Prompt中过于强硬地表达偏好
- 没有给AI"挑战你"的许可

**应对策略**：
```
# 在Plan阶段明确声明
请作为Staff Engineer，如果有以下情况，请直接指出：
- 我的假设可能有误
- 方案有明显的技术风险
- 有更好的替代方案我未考虑
- 这个决策可能导致长期维护问题

我需要你的专业判断，而不是附和。
```

### 模式四：Prototype Prison

**症状**：
- 快速原型变成了生产代码
- 技术债被"以后再重构"无限推迟
- "能跑就行"变成了永久标准

**根本原因**：
- 没有明确的原型/生产代码边界
- 缺少质量门禁

**应对策略**：
```
# 原型标记
在文件头部显式标记：
// PROTOTYPE CODE - NOT PRODUCTION READY
// Known issues:
// - No error handling
// - Not scalable
// - Missing tests
```

设定"原型转生产"的检查清单，不满足标准不能合并。

### 模式五：Model Mismatch

**症状**：
- 用Claude Opus写简单的CRUD代码
- 用GPT-3.5做复杂的架构设计
- 成本与效果不匹配

**根本原因**：
- 没有根据任务难度选择合适的模型

**应对策略**：

**模型选择决策树**：
```
任务类型 → 推荐模型

纯代码补全（函数级） → GPT-4o-mini / Claude Haiku
简单CRUD / 脚本编写 → GPT-4o / Claude Sonnet
架构设计 / 复杂问题 → Claude Opus / GPT-4o（with thinking）
需要代码库理解 → Claude（长窗口） / GPT-4o（with artifacts）
```

**成本优化原则**：
- 80%的任务用中等模型完成
- 20%的关键决策用顶级模型
- 能用小模型就别用大模型

## 1.5 防御系统

AI时代，工程师的防御系统比以往任何时候都重要。

### 防御层一：Git安全网

**黄金法则**：**每一个增量都要commit，每一次重大变更都要branch。**

```
feature/workflow-engine (分支)
├── commit: 添加DAG基础数据结构
├── commit: 实现节点执行逻辑
├── commit: 添加错误处理
├── commit: 编写单元测试
└── commit: 性能优化
```

**Commit Message规范**：
```
类型(范围): 简短描述

详细说明（为什么做这个变更）

相关issue: #123
Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
```

**为什么保留"Co-Authored-By"？**
- 法律合规：AI生成内容的版权归属
- 历史追溯：未来review时知道哪些代码是AI辅助的
- 责任清晰：你是Architect，AI是Implementor

### 防御层二：自动化测试

**AI生成代码必须伴随测试**。

```
# 测试先行策略（Test-Aware Prompting）
在让AI写功能代码时，同时要求：
1. 写测试
2. 解释测试策略
3. 列出边界条件

示例：
"请实现X功能，同时提供：
1. 核心逻辑代码
2. 单元测试（覆盖正常流程和边界条件）
3. 集成测试场景
4. 测试策略说明"
```

**测试层级**：
- L1：单元测试 - AI生成，你review
- L2：集成测试 - 你设计，AI辅助
- L3：端到端测试 - 你主导，AI辅助编写

### 防御层三：Code Review强制流程

即使代码是AI生成的，Code Review也不能省。

**Review Checklist**：
```
# 功能性
- [ ] 符合需求
- [ ] 边界条件处理
- [ ] 错误处理完善

# 架构性
- [ ] 符合整体设计
- [ ] 模块职责清晰
- [ ] 接口设计合理

# 代码质量
- [ ] 命名清晰
- [ ] 没有magic number/string
- [ ] 注释适当（不过度也不过少）

# 可维护性
- [ ] 测试覆盖充分
- [ ] 日志位置合理
- [ ] 易于调试
```

**AI辅助Review**：
```
请Review这段代码，使用以下checklist：
[粘贴checklist]

对于每个问题，请指出：
1. 具体位置
2. 为什么是问题
3. 如何修复
```

### 防御层四：监控和可观测性

代码上线后，真正的考验才开始。

**必须埋点的指标**：
- 功能使用情况（是否有人在用）
- 错误率（AI可能遗漏的边界条件）
- 性能指标（AI不太会优化性能）

**AI生成监控代码**：
```
"请为这个功能添加监控：
1. 关键操作的埋点
2. 错误捕获和上报
3. 性能指标收集
4. 告警规则建议"
```

## 1.6 最小可执行资产

读完这一章，你应该立刻能做的事情。

### 资产一：EPB工作流模板

创建一个文件 `epb-workflow-template.md`：

```markdown
# AI-First 开发工作流

## Explore 阶段
- [ ] 问题解构：5个Whys
- [ ] 约束识别：技术/业务/团队
- [ ] 信息收集：相关文档/竞品/最佳实践
- [ ] 选项生成：至少3个可行路径

## Plan 阶段
- [ ] 架构设计：模块划分/接口定义
- [ ] 任务分解：WBS，明确依赖关系
- [ ] 风险评估：技术风险/应对方案
- [ ] 验收标准：每个任务的done定义

## Build 阶段
- [ ] 增量实现：按任务清单逐个完成
- [ ] 持续测试：每个增量都要验证
- [ ] 代码整理：及时重构，保持质量
- [ ] 文档更新：同步更新.kc.md

## 每个阶段结束的检查点
- Explore → Plan：有清晰的方向和选项
- Plan → Build：有详细的任务清单
- Build → Done：所有测试通过，代码已review
```

### 资产二：会话启动检查清单

创建一个文件 `session-checklist.md`：

```markdown
# 开发会话启动检查清单

## 会话前准备
- [ ] 明确本次会话的目标（一句话）
- [ ] 准备好上下文文件（.kc.md）
- [ ] 确定AI的角色定位

## 会话开始时
```text
# Project Context
[粘贴项目信息]

# Session Goal
[粘贴本次目标]

# AI Role
[声明角色期望]

# Context
[加载必要的上下文]

## 会话中
- [ ] 每5轮检查一次方向
- [ ] 重要决策记录到.kc.md
- [ ] 代码增量commit

## 会话结束时
- [ ] 总结产出
- [ ] 更新知识文件
- [ ] 确定下次会话目标
```

### 资产三：模型选择速查表

打印出来，贴在显示器旁边：

```
┌─────────────────────────────────────────────────────────┐
│                    模型选择决策树                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  任务类型               │  推荐模型                     │
│  ──────────────────────┼───────────────────────────    │
│  代码补全（函数级）     │  GPT-4o-mini / Haiku         │
│  简单脚本/CRUD          │  GPT-4o / Sonnet             │
│  架构设计/复杂问题      │  Opus / GPT-4o (thinking)    │
│  代码库理解             │  Claude（长窗口）            │
│  文档/解释性内容        │  Sonnet / GPT-4o             │
│                                                         │
│  成本原则：                                           │
│  • 80%任务用中等模型                                   │
│  • 20%关键决策用顶级模型                                │
│  • 能省则省                                             │
└─────────────────────────────────────────────────────────┘
```

### 资产四：你的第一个.kc.md

创建 `project.kc.md`：

```markdown
# 项目知识累积文件

## 项目概述
- 项目类型：
- 技术栈：
- 当前阶段：

## 核心概念
[记录项目中的关键概念和术语]

## 已做决策
[记录重要的技术决策]

## 待解决问题
[记录需要后续处理的问题]

## 相关文档
[链接到相关的设计文档、API文档等]

## 代码结构
[简述目录结构和关键文件位置]
```

### 资产五：Vibe Coding自检清单

创建 `vibe-coding-checklist.md`：

```markdown
# Vibe Coding 自检清单

每次开发前，问自己：
- [ ] 我有明确的Plan吗？
- [ ] 我知道AI在这个任务中的角色吗？
- [ ] 我有测试策略吗？
- [ ] 我知道什么时候该停下吗？

如果任何一个答案是"否"，你可能在Vibe Coding。

停下，回到Explore阶段。
```

---

## 本章小结

AI-First工程不是简单的"用AI写代码"，而是工作方式的根本重构。核心要点：

1. **EPB三阶段框架**：20%探索 → 30-50%规划 → 20%构建
2. **AI角色清晰化**：Plan阶段的Staff Engineer，Build阶段的Senior Intern
3. **防御系统**：Git网、自动化测试、Code Review、监控
4. **远离Vibe Coding**：它是最危险的陷阱，让你感觉快而实际慢

下一章，我们将深入探讨**代码生成与演进的工程模式**，看看如何在保持代码质量的同时，最大化AI的效能。

---

**【工程推断】** 本章内容基于2024-2025年的最佳实践总结。AI模型迭代速度极快，具体模型名称和推荐可能会过时，但EPB框架和工作流原则是相对稳定的。核心思想是：无论AI如何进化，人类工程师的价值在于**定义问题、设定方向、确保质量**。
