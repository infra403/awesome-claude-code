# Golang 项目开发规范

## 工作流程

开发任何 feature 必须按以下顺序执行：

1. **阅读 feature 文档** → 明确需求范围
2. **运行现有测试** → 确保基线通过，如不通过则报告
3. **分析代码结构** → 确定代码放置位置，检查可复用的组件和接口
4. **检查调用方** → 修改函数前，列出所有调用方并评估影响
5. **编写代码** → 遵循下方规范
6. **验证构建** → `go build ./...` && `go vet ./...`
7. **运行测试** → 确保新增测试 100% 通过，现有测试不被破坏

## 必须询问用户的情况

遇到以下情况时，**停止操作并询问用户**：

- 需要新增外部组件接口
- 需要修改已有函数签名、结构体字段、接口定义
- 需要修改数据库表结构或删除字段
- feature 文档未明确说明的功能点
- 现有测试基线不通过
- 存在多种实现方案需要选择

## 硬性规则（必须遵守）

### 文件与目录
- 禁止读取 `config/` 目录
- 禁止新建目录、删除文件、生成文档

### 依赖
- 禁止引入新框架、新依赖、新配置项
- 外部组件接口必须复用现有的

### 接口兼容
- 禁止修改已有函数签名、结构体字段、接口方法
- 禁止删除公开方法或字段

### 代码质量
- 禁止 panic，必须返回 error
- 禁止 TODO 注释
- 禁止假数据或硬编码测试数据
- 禁止多层 if 嵌套，使用 early return
- 单函数业务逻辑不超过 50 行

### 测试
- 禁止修改现有测试代码
- 新增测试必须使用 mock 且 100% 通过

### 构建
- 必须通过 `go build`、`go vet`、golint
- 禁止提交无法编译的代码

## Go 代码规范（参考 Uber Go Style Guide）

### 错误处理
- 错误只处理一次，避免重复处理
- 使用 error wrapping 添加上下文：`fmt.Errorf("failed to do x: %w", err)`
- 编译时验证接口实现：`var _ Interface = (*Type)(nil)`

### 命名规范
- 包名：简短清晰，不加冗余前缀
- 函数名：描述性命名，Printf 风格函数以 "f" 结尾
- 私有全局变量：使用下划线前缀 `_privateVar`

### 包组织
- import 顺序：标准库 → 第三方 → 本地包
- 相关声明放在一起
- 避免循环依赖

### 性能
- 字符串转换用 `strconv` 而非 `fmt`
- 已知大小时预分配 slice/map 容量
- 避免重复 string-to-byte 转换

### 反模式（禁止）
- 禁止使用指向 interface 的指针
- 禁止在导出结构体中嵌入 mutex
- API 边界处必须复制 slice/map，防止意外修改
- 禁止 fire-and-forget goroutine，必须管理生命周期
- 枚举从 1 开始，避免与零值混淆

### 结构
- 使用 `defer` 做清理，开销可忽略
- channel 大小为 0 或 1，更大需说明理由
- 零值 mutex 可直接使用，无需初始化

## 软性规则（参考现有代码）

### 代码组织
- 业务划分与现有保持一致
- 代码放置到对应业务目录
- API 层只做路由和参数校验，业务逻辑放 service 层

### 代码风格
- HTTP 调用：参考现有 client 实现
- 错误处理：参考现有错误处理方式
- 日志：使用现有 logger 实例
- Metrics：统一位置管理，参考现有模式
- Trace：参考现有模式
- 并发：涉及共享状态时参考现有并发处理

### 边界处理
- 处理 nil 指针、零值、空切片/map

### 注释
- 仅保留功能层面必要注释
- 对外 API 必须添加 swagger 注释

## 修改现有功能

修改前必须说明：
1. 修改理由
2. 修改内容
3. 影响范围
